{"searchDocs":[{"title":"概述","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/ci_commands/overview/","content":"概述 虽然日常开发涉及多种复杂的 Git 操作，例如在分支之间切换、从服务器获取增量更改以及浏览历史记录。但是相比之下，当持续集成 (CI) 流水线检出一个 Git 分支时，通常是一个更简单的操作。CI 执行任务过程中所用到的文件夹或整个虚拟机可能在作业完成后立即被丢弃。因此，这两种用例需要不同的 Git 优化方法。 Sparo 提供了一个单独的命令行工具 sparo-ci，专门针对 CI 流水线进行了优化。当前实现采用以下方法： 使用 treeless clone 而非 blobless clone，因为在 CI 环境会很少需要使用完整的 Git 历史记录。 Shallow clone 是一种常见的替代方案，但在支持需要与基准分支进行比较的增量构建或发布操作时会遇到困难。 配置了稀疏检出，并包含了骨架文件夹。 目前，sparo-ci 支持两个子命令用于 CI： sparo-ci checkoutsparo-ci clone","keywords":"","version":"下一个"},{"title":"sparo-ci checkout","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/ci_commands/sparo-ci_checkout/","content":"sparo-ci checkout sparo-ci checkout 用于 CI 场景的检出命令。它目前只接受项目选择器，例如 --to 和 --from。 选项： --help 显示帮助 [boolean] -t, --to 查看 https://rushjs.io/pages/developer/selecting_subsets/#--to 了解更多详情。 [array] -f, --from 查看 https://rushjs.io/pages/developer/selecting_subsets/#--from 了解更多详情。 [array] ","keywords":"","version":"下一个"},{"title":"sparo-ci clone","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/ci_commands/sparo-ci_clone/","content":"sparo-ci clone sparo-ci clone &lt;repository&gt; [directory] 位置参数: repository 要克隆的远程仓库地址。 [string] [required] directory 要克隆到的新目录名称。如果未显式指定目录， 将使用源仓库的“humanish”部分 （对于 /path/to/repo.gitService 使用 repo，对于 host.xz:foo/.gitService 使用 foo）。 仅当目录为空时才允许克隆到现有目录。 [string] 选项: --help 显示帮助 [boolean] ","keywords":"","version":"下一个"},{"title":"sparo auto-config","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_auto-config/","content":"","keywords":"","version":"下一个"},{"title":"自动配置设置​","type":1,"pageTitle":"sparo auto-config","url":"/sparo/zh-cn/pages/commands/sparo_auto-config/#自动配置设置","content":" 实现可以在 GitService.ts 中找到。以下是当前应用设置的摘要：  pull.rebase=true fetch.prune=true fetch.showForcedUpdates=false feature.manyFiles=true core.fsmonitor=true core.fscache=true core.untrackedcache=true oh-my-zsh.hide-status=1 oh-my-zsh.hide-dirty=1 lfs.allowincompletepush=true lfs.concurrenttransfers=32 push.autoSetupRemote=true  ","version":"下一个","tagName":"h2"},{"title":"sparo fetch","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_fetch/","content":"sparo fetch sparo fetch [remote] [branch] 将远程分支获取到本地 位置参数: remote [string] branch [string] 选项: -h, --help 显示帮助 [boolean] ","keywords":"","version":"下一个"},{"title":"sparo clone","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_clone/","content":"sparo clone sparo clone &lt;repository&gt; [directory] 位置参数： repository 要克隆的远程仓库。 [string] [required] directory 要克隆到的新目录名称。如果未明确指定目录名称，则使用源仓库的 名字部分（对于 /path/to/repo.gitService 使用 repo，对于 host.xz:foo/.gitService 使用 foo）。仅当目录为空时，才允许克隆 到现有目录中。 [string] 选项： -h, --help 显示帮助 [boolean] -s, --skip-git-config 默认情况下，Sparo 会自动配置您即将克隆的仓库的推荐 git 设置。如果您不希望包含此步骤，可以使用输入参数 --skip-git-config [boolean] [default: false] -b, --branch 指定要克隆的分支 [string] --profile [array] [default: []] ","keywords":"","version":"下一个"},{"title":"sparo checkout","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_checkout/","content":"sparo checkout sparo checkout [branch] [start-point] 更新工作树中的文件，以匹配索引或指定树中的版本。如果未提供路径规范， git checkout 还将更新 HEAD，将指定分支设置为当前分支。 位置参数： branch [string] start-point [string] 选项： --help 显示帮助 [boolean] -b 创建一个新分支，并在 &lt;start-point&gt; 处启动 [boolean] -B 创建一个新分支，并在 &lt;start-point&gt; 处启动；如果已存在， 将其重置到 &lt;start-point&gt; [boolean] --profile 根据指定的配置文件检出项目。这些配置文件将被记录， 并被其他 sparo 命令重用。例如，在运行 &quot;sparo checkout &lt;branch&gt;&quot; 后，会基于重用的配置文件进行稀疏检出 [array] [default: []] --add-profile 使用记录的配置文件和指定的附加配置文件检出项目。 将指定的附加配置文件添加到 sparo 记录的配置文件中 [array] [default: []] --no-profile 检出项目时不使用任何配置文件，并清除所有记录的配置文件 [boolean] --to 检出项目直到（并包括）项目 &lt;to..&gt;，可以与选项 --profile/--add-profile 一起使用，以形成两个选项的并集选择。此处的项目选择器将 永远不会取代配置文件已检出的内容 [array] [default: []] --from 检出项目从（包括其自身及其所有依赖项）项目 &lt;from..&gt; 下游开始， 可以与选项 --profile/--add-profile 一起使用， 以形成两个选项的并集选择。此处的项目选择器将 永远不会取代配置文件已检出的内容 [array] [default: []] ","keywords":"","version":"下一个"},{"title":"sparo git-clone","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_git-clone/","content":"sparo git-clone 这是 git clone 的镜像子命令。它具有与相应 Git 子命令相同的功能，但支持 Sparo 可选的匿名计时数据收集。 sparo git-clone [--template=&lt;template-directory&gt;] [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror] [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;] [--dissociate] [--separate-git-dir &lt;git-dir&gt;] [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags] [--recurse-submodules[=&lt;pathspec&gt;]] [--[no-]shallow-submodules] [--[no-]remote-submodules] [--jobs &lt;n&gt;] [--sparse] [--[no-]reject-shallow] [--filter=&lt;filter&gt; [--also-filter-submodules]] [--] &lt;repository&gt; [&lt;directory&gt;] 详情请参阅 Git 文档中的 git clone。","keywords":"","version":"下一个"},{"title":"sparo git-checkout","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_git-checkout/","content":"sparo git-checkout 这是 git checkout 的镜像子命令。它具有与相应 Git 子命令相同的功能，但支持 Sparo 可选的匿名计时数据收集。 sparo git-checkout [-q] [-f] [-m] [&lt;branch&gt;] sparo git-checkout [-q] [-f] [-m] --detach [&lt;branch&gt;] sparo git-checkout [-q] [-f] [-m] [--detach] &lt;commit&gt; sparo git-checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new-branch&gt;] [&lt;start-point&gt;] sparo git-checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…​ sparo git-checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] --pathspec-from-file=&lt;file&gt; [--pathspec-file-nul] sparo git-checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;…​] 详情请参阅 Git 文档中的 git checkout。","keywords":"","version":"下一个"},{"title":"概述","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/overview/","content":"","keywords":"","version":"下一个"},{"title":"mirrored命令​","type":1,"pageTitle":"概述","url":"/sparo/zh-cn/pages/commands/overview/#mirrored命令","content":" 每个子命令在本文档中都有自己的页面，mirrored命令除外，它们已经在 Git 文档中进行了介绍。为了方便起见，下面的表格列出了最重要的&quot;porcelain&quot;子命令，然而每个 Git 子命令都受支持。  子命令\t概述git add\t将文件内容添加到索引 git am\t从邮箱中应用一系列补丁 git archive\t从指定树创建文件归档 git bisect\t使用二分查找找到引入错误的提交 git branch\t列出、创建或删除分支 git bundle\t通过归档移动对象和引用 git checkout\t切换分支或还原工作树文件 git cherry-pick\t应用某些现有提交引入的更改 git citool\t图形化替代 git-commit git clean\t从工作树中删除未跟踪的文件 git clone\t将仓库克隆到一个新目录中 git commit\t将更改记录到仓库 git describe\t基于可用引用为对象赋予一个可读名称 git diff\t显示提交之间的更改、提交与工作树之间的更改等 git fetch\t从另一个仓库下载对象和引用 git format-patch\t为电子邮件提交准备补丁 git gc\t清理不必要的文件并优化本地仓库 git gitk\tGit 仓库浏览器 git grep\t打印匹配模式的行 git gui\tGit 的可移植图形界面 git init\t创建一个空的 Git 仓库或重新初始化现有的仓库 git log\t显示提交日志 git maintenance\t运行任务以优化 Git 仓库数据 git merge\t将两个或多个开发历史合并在一起 git mv\t移动或重命名文件、目录或符号链接 git notes\t添加或查看对象注释 git pull\t从另一个仓库或本地分支获取并集成 git push\t更新远程引用及其关联对象 git range-diff\t比较两个提交范围（例如分支的两个版本） git rebase\t在另一个基底上重新应用提交 git reset\t将当前 HEAD 重置为指定状态 git restore\t恢复工作树文件 git revert\t撤销某些现有的提交 git rm\t从工作树和索引中删除文件 git shortlog\t总结 'git log' 输出 git show\t显示各种类型的对象 git sparse-checkout\t将工作树减少到跟踪文件的子集 git stash\t将脏的工作目录中的更改暂存 git status\t显示工作树状态 git submodule\t初始化、更新或查看子模块 git switch\t切换分支 git tag\t创建、列出、删除或验证使用 GPG 签名的标签对象 git worktree\t管理多个工作树 . . .\t...以及许多其他子命令，包括 shell PATH 中找到的任何自定义命令 ","version":"下一个","tagName":"h2"},{"title":"sparo init-profile","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_init-profile/","content":"sparo init-profile 用法: sparo init-profile --profile &lt;profile&gt; 选项: -h, --help 显示帮助 [boolean] --profile 要初始化的配置文件名称。 [string] [required] ","keywords":"","version":"下一个"},{"title":"sparo git-pull","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_git-pull/","content":"sparo git-pull 这是 git pull 的镜像子命令。它具有与相应 Git 子命令相同的功能，但支持 Sparo 可选的匿名计时数据收集。 sparo git-pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…​]] 详情请参阅 Git 文档中的 git pull。","keywords":"","version":"下一个"},{"title":"sparo git-fetch","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_git-fetch/","content":"sparo git-fetch 这是 git fetch 的镜像子命令。它具有与相应 Git 子命令相同的功能，但支持 Sparo 可选的匿名计时数据收集。 sparo git-fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…​]] sparo git-fetch [&lt;options&gt;] &lt;group&gt; sparo git-fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…​] sparo git-fetch --all [&lt;options&gt;] 详情请参阅 Git 文档中的 git fetch。","keywords":"","version":"下一个"},{"title":"sparo pull","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_pull/","content":"sparo pull sparo pull [options] [repository] [refspec...] [--profile &lt;profile_name&gt; | --no-profile] 将远程仓库的更改合并到当前分支。 选项: --help 显示帮助 [boolean] --profile [array] [default: []] ","keywords":"","version":"下一个"},{"title":"sparo list-profiles","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/commands/sparo_list-profiles/","content":"sparo list-profiles sparo list-profiles 列出所有可用的配置文件或查询包含指定项目名称的配置文件 选项: -h, --help 显示帮助 [boolean] --project 列出所有包含此指定项目名称的配置文件 [string] ","keywords":"","version":"下一个"},{"title":"<profile-name>.json","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/configs/profile_json/","content":"","keywords":"","version":"下一个"},{"title":"另见​","type":1,"pageTitle":"<profile-name>.json","url":"/sparo/zh-cn/pages/configs/profile_json/#另见","content":" Sparo 配置文件 ","version":"下一个","tagName":"h2"},{"title":"Git 优化","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/reference/git_optimization/","content":"Git 优化 默认情况下，git clone 将下载 Git 仓库中的每个文件，以及每个文件的完整历史记录。对于小型仓库来说，这不是什么大问题。但随着您的 monorepo 累积项目和多年的历史记录，Git 操作会变得越来越慢，直到有一天 git status 需要 10 秒或更长时间。该怎么办？ Git 提供了这些基本解决方案，适用于中型仓库并且易于使用： 浅克隆 (Shallow clone) 允许只克隆几个提交，但通常仅适用于一次性克隆，例如 CI 任务。 部分克隆 (Partial clone) 允许在不包含文件内容（无 Blob 克隆）甚至提交详细信息（无树 克隆）的情况下进行克隆，大大加快了 git clone 的时间，并允许在 git checkout 期间获取这些详细信息。 大文件存储 (LFS) 可以将二进制文件移动到单独的服务器，在检出时按需下载。然而，LFS 的配置非常复杂，如果配置不当，可能会导致更差的性能。 然而，要在大型仓库中实现良好的性能，需要使用更复杂的 Git 功能，例如： Git 文件系统监视器 和 后台维护 是监视更改并定期预取服务器数据的后台进程。用户必须手动注册/注销工作目录，并记得在不需要时“暂停”服务。 Git 工作树 (worktrees) 允许在您的计算机上使用多个工作目录共享一个 .git 文件夹，避免了多次克隆的成本。然而，这一功能也有一些尴尬的限制，例如同一个分支不能在两个工作树中检出，并且 Git 钩子也是共享的。 稀疏检出 (Sparse checkout) 允许 git checkout 提取文件的子集，而不是整个目录结构。结合部分克隆，稀疏检出是 Git 优化的“战斧”：尽管无关的项目和历史会积累，但您的等待时间将与您实际需要的文件成正比。","keywords":"","version":"下一个"},{"title":"入门指南","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/guide/getting_started/","content":"","keywords":"","version":"下一个"},{"title":"第 1 步：升级 Git​","type":1,"pageTitle":"入门指南","url":"/sparo/zh-cn/pages/guide/getting_started/#第-1-步升级-git","content":" 请记住将 Git 升级到最新版本！许多 Git 优化功能相对较新，在旧版本的软件中不可用。  对于 macOS，我们推荐使用 brew install git。对于其他操作系统，请参阅 Git 文档 了解安装说明。  ","version":"下一个","tagName":"h2"},{"title":"第 2 步：克隆您的 Rush monorepo​","type":1,"pageTitle":"入门指南","url":"/sparo/zh-cn/pages/guide/getting_started/#第-2-步克隆您的-rush-monorepo","content":" 克隆您的 RushJS monorepo：  # 从 NPM 全局安装 Sparo CLI npm install -g sparo # 使用 Sparo 克隆你的仓库 sparo clone https://github.com/my-company/my-monorepo.git cd my-monorepo   👉 对于真实世界的演示，尝试克隆这个仓库：https://github.com/Azure/azure-sdk-for-js.git  &quot;sparo clone&quot; 的优化方式：  仅获取默认分支（通常是 main 分支）。这显著减少了下载大小。 启用了 Git 无 Blob 的部分克隆以延迟下载文件内容。 使用 Git 稀疏检出 仅克隆&quot;骨架&quot;文件夹，其中包括所有工作区的 package.json 文件，但不包括源代码子文件夹。 稀疏检出已配置为更高效的&quot;锥形模式&quot;。  提示: 如果想查看执行的操作和 Git 操作，使用 sparo --debug clone 代替 sparo clone。  💡 目前支持 PNPM 和 Yarn 工作区的功能计划中，但尚未实现。欢迎贡献！  ","version":"下一个","tagName":"h2"},{"title":"第 3 步：创建稀疏配置文件​","type":1,"pageTitle":"入门指南","url":"/sparo/zh-cn/pages/guide/getting_started/#第-3-步创建稀疏配置文件","content":" 定义一个 Sparo 配置文件，描述 Git 稀疏检出的仓库文件夹子集。  # 将模板写入 common/sparo-profiles/my-team.json sparo init-profile --profile my-team   编辑创建的 my-team.json 文件并添加一个选择器。例如：  common/sparo-profiles/my-team.json  { &quot;selections&quot;: [ { &quot;selector&quot;: &quot;--to&quot;, &quot;argument&quot;: &quot;my-rush-project&quot; } ] }   👉 如果您正在演示 azure-sdk-for-js，请将 my-rush-project 替换为 @azure/arm-commerce。  在上面的例子中，--to 项目选择器 指示 Sparo 检出工作区中构建 my-rush-project 所需的所有依赖项。  # 将您的配置文件提交到 Git。（此步骤在快速演示中已跳过。） # Sparo 配置文件通常应存储在 Git 中，因为这可以使您在分支之间移动时无需担心 # 某个分支中存在哪些项目。 sparo add . sparo commit -m &quot;Created a new Sparo profile&quot;   ","version":"下一个","tagName":"h2"},{"title":"第 4 步：检出您的 Sparo 配置文件​","type":1,"pageTitle":"入门指南","url":"/sparo/zh-cn/pages/guide/getting_started/#第-4-步检出您的-sparo-配置文件","content":" --profile 参数可以与 sparo checkout 一起使用（未来也可以与 sparo clone 和 sparo pull 一起使用）。此参数指定要选择的 JSON 文件的名称。您还可以组合多个配置文件（sparo checkout --profile p1 --profile p2），在这种情况下，将使用它们选择的集合的并集。组合配置文件是一个高级场景，但在例如您的拉取请求将影响属于多个团队的项目集时非常有用。  基于 common/sparo-profiles/my-team.json 的稀疏检出  sparo checkout --profile my-team   关于 &quot;sparo checkout&quot; 的更多信息：  Sparo 根据您的配置文件选择自动生成 Git 的 $GIT_DIR/info/sparse-checkout 配置文件。为避免冲突，请不要直接编辑此文件或使用其他工具（如 git sparse-checkout）重写它。（这样做不会破坏任何东西，但可能会干扰 Sparo 的操作。） 要仅检出骨架（返回到第 1 步尚未选择任何配置文件的初始状态），请指定 --no-profile 代替 --profile NAME。 要添加更多配置文件，并与现有选择组合，请使用 --add-profile NAME 代替 --profile NAME。例如，以下两个命令与 sparo checkout --profile p1 --profile p2 产生相同的结果： sparo checkout --profile p1 sparo checkout --add-profile p2   ","version":"下一个","tagName":"h2"},{"title":"第 5 步：使用镜像子命令​","type":1,"pageTitle":"入门指南","url":"/sparo/zh-cn/pages/guide/getting_started/#第-5-步使用镜像子命令","content":" 在日常工作中，考虑选择 镜像子命令，例如 sparo revert 而不是 git revert。Sparo 包装器提供 (1) 更好的默认设置，(2) 更好的性能建议，以及 (3) 可选的匿名化性能指标。  示例：  sparo pull sparo commit -m &quot;Example command&quot;  ","version":"下一个","tagName":"h2"},{"title":"贡献指南","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/support/contributing/","content":"贡献指南 在这个 monorepo 中构建项目： 安装 RushJS 工具： npm install -g @microsoft/rush 克隆仓库： git clone https://github.com/tiktok/sparo.git 安装依赖项 cd sparo rush install 构建所有项目 rush build 如何调用您本地构建的 sparo 命令： cd apps/sparo node lib/start.js ","keywords":"","version":"下一个"},{"title":"安全性","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/reference/security/","content":"","keywords":"","version":"下一个"},{"title":"安全场景​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#安全场景","content":" Git 没有提供正式的安全规范，因此为了便于分析 Sparo 贡献，我们确定了一些暗示安全需求的使用场景。我们欢迎您的反馈——如果我们忽略了重要的用例，或者 Git 的行为与描述不符，请告知我们。  ","version":"下一个","tagName":"h2"},{"title":"SS1: 安全地克隆不受信任的仓库​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#ss1-安全地克隆不受信任的仓库","content":" 假设一个不熟悉的远程 Git 仓库包含恶意文件，其中包括恶意配置文件，如 .gitattributes、.gitignore 和 Git 钩子脚本。以下操作应被认为是安全的：  使用 git clone 克隆远程仓库。使用 git checkout 检出文件。使用 git commit 提交本地文件的修改。  Git 通过默认忽略 Git 钩子和 .gitattributes 过滤器来确保安全。用户必须显式运行命令以“选择加入”，表示他们相信该仓库没有恶意代码。例如，调用 rush install 将注册预定义的 Git 钩子，因为 NPM 安装涉及执行不受信任的脚本，因此表示信任克隆的仓库。另一个例子是，如果 .gitattributes 引用了 LFS 过滤器，用户必须先通过运行 git lfs install 选择加入，这表明他们相信过滤器的作者已实施安全保护措施以防止恶意输入。  Sparo 引入了额外的配置文件，例如 &lt;profile-name&gt;.json。这些配置文件的解析也必须将输入视为潜在的恶意，并提供相同的安全保证。  ","version":"下一个","tagName":"h3"},{"title":"SS2: 安全地克隆不受信任的仓库参数​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#ss2-安全地克隆不受信任的仓库参数","content":" 诸如 git clone https://github.com/example/project.git 之类的命令会写入一个名为 project 的子文件夹。Git 文档将此称为 URL 的&quot;humanish&quot;部分。  考虑一个接收 REPOSITORY 参数作为文本字符串并随后正确进行 shell 转义后调用 git clone REPOSITORY 的远程服务。在计算 humanish 文件夹名称时，Git 不应包含诸如 .. 或 / 之类的特殊字符，这些字符会导致操作将克隆的文件写入预期文件夹之外。  当然，如果使用 git clone https://github.com/example/project.git my-folder 指定了显式目标文件夹，则不应将任何文件克隆到 my-folder 文件夹之外。  ","version":"下一个","tagName":"h3"},{"title":"SS3: Git 参数可能包含特殊字符​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#ss3-git-参数可能包含特殊字符","content":" Shell 解释器通常会转换涉及特殊字符的表达式，例如 $、%、( 等。例如：  # 问题：Bash 会将 &quot;$project&quot; 替换为 # 名为 &quot;project&quot; 的环境变量的值。 git clone https://github.com/example/project.git $project   这需要进行转义：  # 这个反斜杠转义确保在创建的文件夹名称中包含一个字面上的美元符号： git clone https://github.com/example/project.git \\$project   当 sparo 命令行调用子进程（如 git）时，它必须仔细确保进程参数被正确转义，以避免被 shell 转换。例如，如果 \\$project 在子进程调用期间被 shell 扩展，转义将失效，这可能被利用来规避 Sparo 的其他安全保证。如果某些字符无法通过 Node.js 安全转义，则应通过错误消息将其拒绝。  ","version":"下一个","tagName":"h3"},{"title":"安全假设​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#安全假设","content":" 同时指出一些不期望是安全的方面也很有用。  ","version":"下一个","tagName":"h2"},{"title":"假设：Shell 环境变量是受信任的​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#假设shell-环境变量是受信任的","content":" 在大多数情况下，git CLI 假设 shell 环境变量是受信任的。例如，它依赖 PATH 变量来发现 ssh 二进制文件的位置，并且大多数父进程的变量会传递给子进程。  由于 Sparo 工具是由 Node.js 运行时调用的，通过环境变量（如 NODE_OPTIONS）执行任意代码是可能的。  ","version":"下一个","tagName":"h2"},{"title":"假设：命令行通常是受信任的​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#假设命令行通常是受信任的","content":" git 命令行接受诸如 -c 之类的参数，这些参数可以触发任意代码的执行。因此，通常情况下，我们假设命令行参数是受信任的。然而，某些参数可以提供更严格的保证，例如 SS3 中提到的 git clone 的 &lt;repository&gt; 参数。  ","version":"下一个","tagName":"h2"},{"title":"假设：命令可能会消耗过多资源​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#假设命令可能会消耗过多资源","content":" 诸如 git clone 之类的命令可能会消耗任意数量的磁盘空间或需要任意长的时间才能完成。一般来说，拒绝服务攻击对于这种开发工具来说不被认为是重要的风险。  ","version":"下一个","tagName":"h2"},{"title":"假设：STDOUT 和 STDERR 可能包含任意字符​","type":1,"pageTitle":"安全性","url":"/sparo/zh-cn/pages/reference/security/#假设stdout-和-stderr-可能包含任意字符","content":" 在调用 git CLI 时，控制台输出可能包含由钩子脚本或其他 shell 命令打印的字符串。这些字符串可能包含不安全的特殊字符，不适合嵌入到其他上下文中，如 HTML 文档或 SQL 字符串文字中。调用进程有责任正确转义 git 或 sparo 进程产生的任何 STDOUT 或 STDERR 输出。 ","version":"下一个","tagName":"h2"},{"title":"Sparo 配置文件","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/guide/sparo_profiles/","content":"","keywords":"","version":"下一个"},{"title":"背景​","type":1,"pageTitle":"Sparo 配置文件","url":"/sparo/zh-cn/pages/guide/sparo_profiles/#背景","content":" Git 的稀疏检出功能通常依赖于存储在 .git/info/sparse-checkout 配置文件中的一组 glob 模式。Git 维护者发现常规的 glob 语法效率太低，因此他们引入了一种&quot;锥形模式&quot;的 glob 解释，这种模式忽略文件匹配模式，只匹配目录。  语法类似于以下内容：  .git/info/sparse-checkout 示例  /* !/*/ /apps/ !/apps/*/ /apps/my-app/ !/apps/my-app/*/ /apps/my-app/_/   为了简化管理，Git 还提供了 git sparse-checkout 命令，用于简化从该文件中添加/删除模式的语法。然而，在一个包含数百个项目的大型 monorepo 中，管理这些 globs 仍然会令人困惑且容易出错。  ","version":"下一个","tagName":"h2"},{"title":"Sparo 改进了稀疏检出​","type":1,"pageTitle":"Sparo 配置文件","url":"/sparo/zh-cn/pages/guide/sparo_profiles/#sparo-改进了稀疏检出","content":" Sparo 通过从称为 配置文件 的配置文件自动生成 .git/info/sparse-checkout 配置，使生活变得更简单。这带来了许多好处：  Sparo 配置文件使用 项目选择器 定义，例如：&quot;给我 app1、app2，以及所有构建它们所需的项目。&quot; 这比指定 globs 更简洁且更易维护。 配置文件存储在配置文件中并提交到 Git。这使得与团队成员共享它们变得容易。 在分支切换时，配置文件会自动更新，确保确定性结果。例如，在检出一个非常旧的分支时，您希望获得旧的配置文件定义，而不是今天的版本。 您可以将多个配置文件组合在一起（sparo checkout --profile team1 --profile team2），选择它们项目的并集。这在修改一个被多个其他团队的项目使用的库项目时非常有用。当然，您可以使用 --from the-library 检出这些项目，但其他团队可能已经在他们的配置文件中包括了其他相关项目。 Sparo 通过施加 git sparse-checkout 之外的额外限制来避免常见错误。这可以避免诸如尝试切换到缺少包含本地修改文件的项目文件夹的配置文件等错误。用户最好先暂存或提交此类修改。  ","version":"下一个","tagName":"h2"},{"title":"配置文件的最佳实践​","type":1,"pageTitle":"Sparo 配置文件","url":"/sparo/zh-cn/pages/guide/sparo_profiles/#配置文件的最佳实践","content":" 您可以向配置文件中添加 JSON 注释。在大型共享代码库中，我们建议在文件顶部添加一个标准化的标题，指示它们的所有权和用途。类似于以下内容：  common/sparo-profiles/example-profile.json  /** * 所有者: 客户服务团队 * 目的: 在处理客户服务应用程序时使用此配置文件。 */ { &quot;$schema&quot;: &quot;https://tiktok.github.io/sparo/schemas/sparo-profile.schema.json&quot;, /** * 一个 Rush 项目选择器列表，指示要包含在稀疏检出中的项目文件夹。 * 选择器将组合以构成项目的并集。详情请参阅 Rush 选择器文档： * https://rushjs.io/pages/developer/selecting_subsets/ */ &quot;selections&quot;: [ { &quot;selector&quot;: &quot;--to&quot;, &quot;argument&quot;: &quot;tag:cs-dashboard&quot; }, { &quot;selector&quot;: &quot;--to&quot;, &quot;argument&quot;: &quot;tag:cs-tools&quot; } ] }   ","version":"下一个","tagName":"h2"},{"title":"组合配置文件​","type":1,"pageTitle":"Sparo 配置文件","url":"/sparo/zh-cn/pages/guide/sparo_profiles/#组合配置文件","content":" 组合配置文件的简单方法是多次指定 --profile。例如：  # 检出 team-a.json、team-b.json、team-c.json 配置文件的并集 # 注意: 这将替换已检出的任何配置文件选择。 sparo checkout --profile team-a --profile team-b --profile team-c   您还可以使用 --add-profile 来逐步组合它们。例如：  # 这三个命令等同于上述命令。 sparo checkout --profile team-a sparo checkout --add-profile team-b sparo checkout --add-profile team-c   如何完全不检出任何配置文件？也就是说，如何返回到仅包含骨架文件夹的干净 sparo clone 的初始状态？答案是使用 --no-profile 参数：  # 尚未实现 - 仅检出骨架文件夹 # 而不应用任何配置文件 sparo checkout --no-profile   如果 sparo checkout 不带 --profile 或 --add-profile 或 --no-profile，则保留现有的配置文件选择。换句话说，您的配置文件选择通常在命令之间是“粘性的”。  ","version":"下一个","tagName":"h2"},{"title":"查询配置文件​","type":1,"pageTitle":"Sparo 配置文件","url":"/sparo/zh-cn/pages/guide/sparo_profiles/#查询配置文件","content":" 用户可以通过调用 sparo list-profiles 命令发现当前分支中的可用配置文件。--project 参数使您可以查询给定项目的相关配置文件。例如：  # 假设您需要为 &quot;example-app&quot; 项目进行修复。 # 哪些稀疏检出配置文件包含 &quot;example-app&quot; 项目？ sparo list-profiles --project example-app # 很好，让我们将 &quot;example-profile&quot; 结果添加到我们当前的检出中 # （与现有配置文件组合）。 sparo checkout --add-profile example-profile   ","version":"下一个","tagName":"h2"},{"title":"另见​","type":1,"pageTitle":"Sparo 配置文件","url":"/sparo/zh-cn/pages/guide/sparo_profiles/#另见","content":" &lt;profile-name&gt;.json 配置文件 ","version":"下一个","tagName":"h2"},{"title":"获取帮助","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/support/help/","content":"","keywords":"","version":"下一个"},{"title":"故障排除提示​","type":1,"pageTitle":"获取帮助","url":"/sparo/zh-cn/pages/support/help/#故障排除提示","content":" 升级到最新的 GIT。 如果您的 Git 版本过旧，Sparo 通常会报告错误。如果最低 Git 版本不够高，请告诉我们！ 如果操作失败，请使用 --debug 进行调查。例如，使用 sparo --debug clone http://my-repo 代替 sparo clone http://my-repo。 ","version":"下一个","tagName":"h2"},{"title":"更新内容","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/support/news/","content":"更新内容 要了解最新版本的更改，请查阅变更日志： CHANGELOG.md","keywords":"","version":"下一个"},{"title":"骨架文件夹","type":0,"sectionRef":"#","url":"/sparo/zh-cn/pages/reference/skeleton_folders/","content":"","keywords":"","version":"下一个"},{"title":"骨架规范​","type":1,"pageTitle":"骨架文件夹","url":"/sparo/zh-cn/pages/reference/skeleton_folders/#骨架规范","content":" 包含的文件夹如下：  整个 common/** 文件夹，通常包括所有重要的配置文件和 Rush 操作的自动安装程序。对于 rush.json 中定义的每个项目，顶级项目文件夹的内容。例如，packages/my-app/package.json 和 packages/my-app/README.md 将被包含，但 packages/my-app/src/index.ts 不会被包含。顶级文件夹 scripts/** 和 plugins/**，因为这些名称通常用于其他重要项目。  当选择了一个 Sparo 配置文件（例如使用 sparo checkout --profile my-team）时，它将引入所选工作区项目下的所有源代码子文件夹。  ","version":"下一个","tagName":"h2"},{"title":"嵌套项目的处理​","type":1,"pageTitle":"骨架文件夹","url":"/sparo/zh-cn/pages/reference/skeleton_folders/#嵌套项目的处理","content":" 在另一个工作区项目下嵌套一个工作区项目并不是最佳实践。例如，应避免以下文件夹组织方式：  packages/x/package.jsonpackages/x/src/index.tspackages/x/y/package.json （项目 y 嵌套在项目 x 内——请避免这样做）packages/x/y/src/index.ts  然而，Sparo 可以正确支持这种场景。例如，如果您的配置文件选择了 x 而未选择 y，那么检出将包含 x/src/index.ts，但不包含 x/y/src/index.ts。 ","version":"下一个","tagName":"h2"}],"options":{"languages":["en","zh"],"id":"default"}}