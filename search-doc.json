{"searchDocs":[{"title":"Sparo profiles","type":0,"sectionRef":"#","url":"/sparo/pages/guide/sparo_profiles","content":"Sparo profiles","keywords":"","version":"Next"},{"title":"Git optimization","type":0,"sectionRef":"#","url":"/sparo/pages/reference/git_optimization","content":"Git optimization By default git clone will download every file in your Git repository, as well as the complete history of every file. For small repositories, that's no big deal. But as your monorepo accumulates projects and years of history, Git operations become slower and slower, until one day git status is taking 10 seconds or more. What to do? Git provides these basic solutions that are easy to use in a medium sized repository: Shallow clone allows cloning only a few commits, but is generally only suitable for throwaway clones such as a CI job. Partial clone allows cloning without file contents (blobless clone) or even commit details (treeless clone), greatly accelerating your git clone time and allowing such details to be fetched during git checkout. Large file storage (LFS) can move binary files to a separate server, downloading them on demand during checkout. Configuration of LFS is tricky however and if done incorrectly may cause worse performance. However, achieving good performance in a large repository requires more complex Git features such as: Git filesystem monitor and background maintenance are background processes that watch for changes and periodically prefetch server data. The user must manually register/unregister working directories and remember to &quot;pause&quot; the service when not needed. Git worktrees allow multiple working directories on your computer to share a single .git folder, avoiding the cost of multiple clones. However this feature comes with awkward limitations, for example the same branch can't be checked out in two worktrees, and Git hooks are also shared. Sparse checkout allows git checkout to extract a subset of files instead of the entire directory structure. Combined with partial clone, sparse checkout is the &quot;battle axe&quot; of Git optimization: although irrelevant projects and history will accumulate, your wait time will be proportional to the files you actually need.","keywords":"","version":"Next"},{"title":"Skeleton folders","type":0,"sectionRef":"#","url":"/sparo/pages/reference/skeleton_folders","content":"","keywords":"","version":"Next"},{"title":"Skeleton specâ€‹","type":1,"pageTitle":"Skeleton folders","url":"/sparo/pages/reference/skeleton_folders#skeleton-spec","content":" The included folders are as follows:  The entire common/** folder, which generally includes all the important config files and autoinstallers for Rush operationsFor every project defined in rush.json, the top-level project folder contents. For example, packages/my-app/package.json and packages/my-app/README.md will be included, but not packages/my-app/src/index.ts.The scripts/** and plugins/** top-level folders, because these names are commonly used for other essential projects.  When a Sparo profile is chosen (for example using sparo checkout --profile my-team), it will bring in all the source code subfolders under the selected workspace projects.  ","version":"Next","tagName":"h2"},{"title":"Handling of nested projectsâ€‹","type":1,"pageTitle":"Skeleton folders","url":"/sparo/pages/reference/skeleton_folders#handling-of-nested-projects","content":" It is not a best practice for a workspace project to be nested under another workspace project. For example, this folder organization should be avoided:  packages/x/package.jsonpackages/x/src/index.tspackages/x/y/package.json (project y is nested inside project x -- don't do this)packages/x/y/src/index.ts  Sparo correctly supports this scenario, however. For example, if your profile selects x but not y, then the checkout will include x/src/index.ts but exclude x/y/src/index.ts. ","version":"Next","tagName":"h2"},{"title":"What's new","type":0,"sectionRef":"#","url":"/sparo/pages/support/news","content":"What's new To find out what's changed in the latest release, please consult the CHANGELOG.md notes.","keywords":"","version":"Next"},{"title":"Getting help","type":0,"sectionRef":"#","url":"/sparo/pages/support/help","content":"Getting help If you encounter questions or problems, please create a GitHub issue. Additional support channels are coming soon.","keywords":"","version":"Next"},{"title":"Overview","type":0,"sectionRef":"#","url":"/sparo/pages/commands/overview","content":"","keywords":"","version":"Next"},{"title":"Mirrored commandsâ€‹","type":1,"pageTitle":"Overview","url":"/sparo/pages/commands/overview#mirrored-commands","content":" Each subcommand has its own page in this documentation, except for the mirrored commands which are already covered by the Git documentation. For convenience, their names are listed in the table below.  Subcommand\tSummarygit add\tAdd file contents to the index git am\tApply a series of patches from a mailbox git archive\tCreate an archive of files from a named tree git bisect\tUse binary search to find the commit that introduced a bug git branch\tList, create, or delete branches git bundle\tMove objects and refs by archive git checkout\tSwitch branches or restore working tree files git cherry-pick\tApply the changes introduced by some existing commits git citool\tGraphical alternative to git-commit git clean\tRemove untracked files from the working tree git clone\tClone a repository into a new directory git commit\tRecord changes to the repository git describe\tGive an object a human readable name based on an available ref git diff\tShow changes between commits, commit and working tree, etc git fetch\tDownload objects and refs from another repository git format-patch\tPrepare patches for e-mail submission git gc\tCleanup unnecessary files and optimize the local repository git gitk\tThe Git repository browser git grep\tPrint lines matching a pattern git gui\tA portable graphical interface to Git git init\tCreate an empty Git repository or reinitialize an existing one git log\tShow commit logs git maintenance\tRun tasks to optimize Git repository data git merge\tJoin two or more development histories together git mv\tMove or rename a file, a directory, or a symlink git notes\tAdd or inspect object notes git pull\tFetch from and integrate with another repository or a local branch git push\tUpdate remote refs along with associated objects git range-diff\tCompare two commit ranges (e.g. two versions of a branch) git rebase\tReapply commits on top of another base tip git reset\tReset current HEAD to the specified state git restore\tRestore working tree files git revert\tRevert some existing commits git rm\tRemove files from the working tree and from the index git shortlog\tSummarize 'git log' output git show\tShow various types of objects git sparse-checkout\tReduce your working tree to a subset of tracked files git stash\tStash the changes in a dirty working directory away git status\tShow the working tree status git submodule\tInitialize, update or inspect submodules git switch\t ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/sparo/pages/guide/getting_started","content":"","keywords":"","version":"Next"},{"title":"Everyday workflowâ€‹","type":1,"pageTitle":"Getting Started","url":"/sparo/pages/guide/getting_started#everyday-workflow","content":" ","version":"Next","tagName":"h2"},{"title":"Step 1: Upgrade Gitâ€‹","type":1,"pageTitle":"Getting Started","url":"/sparo/pages/guide/getting_started#step-1-upgrade-git","content":" Many Git optimizations are relatively new and not available in older versions of the software. For macOS, we recommend to use brew install git. For other operating systems, see the Git documentation for instructions.  ","version":"Next","tagName":"h3"},{"title":"Step 2: Clone your Rush monorepoâ€‹","type":1,"pageTitle":"Getting Started","url":"/sparo/pages/guide/getting_started#step-2-clone-your-rush-monorepo","content":" Clone your RushJS monorepo:  sparo clone https://github.com/my-company/my-monorepo.git   ðŸ‘‰ For a real world demo, try this repo:https://github.com/Azure/azure-sdk-for-js.git  ðŸ’¡ Support for PNPM and Yarn workspaces is planned but not implemented yet. Contributions welcome!  Behind the scenes:  Only the default branch (usually main) is fetched. Git blobless partial clone is enabled to postpone downloading file contents. Git sparse checkout is used to clone only the &quot;skeleton&quot; folders, which includes all workspace package.json files, but excludes the source code subfolders. Sparse checkout is configured for the more efficient &quot;cone mode&quot;. To understand exactly what actions and Git operations are being performed, invoke sparo --debug clone instead of sparo clone.  ","version":"Next","tagName":"h3"},{"title":"Step 3: Create a sparse profileâ€‹","type":1,"pageTitle":"Getting Started","url":"/sparo/pages/guide/getting_started#step-3-create-a-sparse-profile","content":" Define a Sparo profile describing the subset of repository folders for Git sparse checkout. Here is a basic example:  common/sparo-profiles/my-team.json  { &quot;selections&quot;: [ { &quot;selector&quot;: &quot;--to&quot;, &quot;argument&quot;: &quot;my-rush-project&quot; } ] }   The --to project selector instructs Sparo to checkout all dependencies in the workspace that are required to build my-rush-project.  ðŸ‘‰ If you're demoing azure-sdk-for-js, replace my-rush-project with @azure/arm-commerce.  ","version":"Next","tagName":"h3"},{"title":"Step 4: Check out your Sparo profileâ€‹","type":1,"pageTitle":"Getting Started","url":"/sparo/pages/guide/getting_started#step-4-check-out-your-sparo-profile","content":" The --profile parameter can be included with sparo checkout (and in the future also sparo clone and sparo pull). This parameter specifies the name of the JSON file to be selected. You can also combine multiple profiles (sparo checkout --profile p1 --profile p2), in which case the union of their selections will be used. (Combining profiles is an advanced scenario, but useful for example if your pull request will impact sets of projects belonging to multiple teams.)  Sparse checkout based on common/sparo-profiles/my-team.json  sparo checkout --profile my-team   Behind the scenes:  Sparo automatically generates the $GIT_DIR/info/sparse-checkout configuration automatically based on your profile selections. To avoid conflicts, while using Sparo do not edit this file directly or rewrite it using other tools such as git sparse-checkout. To checkout just the skeleton (returning to the initial state from Step 1 where no profile is chosen yet), specify --no-profile instead of --profile NAME. To add more profiles, combining with your existing selection, use --add-profile NAME instead of --profile NAME. For example, these two commands produce the same result as sparo checkout --profile p1 --profile p2: sparo checkout --profile p1 sparo checkout --add-profile p2   ","version":"Next","tagName":"h3"},{"title":"Step 5: Use the mirrored subcommandsâ€‹","type":1,"pageTitle":"Getting Started","url":"/sparo/pages/guide/getting_started#step-5-use-the-mirrored-subcommands","content":" For everyday work, consider choosing mirrored subcommands such as sparo revert instead of git revert. The Sparo wrapper provides (1) better defaults, (2) suggestions for better performance, and (3) optional anonymized performance metrics.  Examples:  sparo pull sparo commit -m &quot;Example command&quot;  ","version":"Next","tagName":"h3"},{"title":"Contributing","type":0,"sectionRef":"#","url":"/sparo/pages/support/contributing","content":"Contributing Building the projects in this monorepo: Install the RushJS tool: npm install -g @microsoft/rush Clone the repo: git clone https://github.com/tiktok/sparo.git Install the dependencies cd sparo rush install Build all projects rush build How to invoke your locally build sparo command: cd apps/sparo node lib/start.js ","keywords":"","version":"Next"},{"title":"<profile-name>.json","type":0,"sectionRef":"#","url":"/sparo/pages/configs/profile_json","content":"","keywords":"","version":"Next"},{"title":"See alsoâ€‹","type":1,"pageTitle":"<profile-name>.json","url":"/sparo/pages/configs/profile_json#see-also","content":" Sparo profiles ","version":"Next","tagName":"h2"},{"title":"Security","type":0,"sectionRef":"#","url":"/sparo/pages/reference/security","content":"","keywords":"","version":"Next"},{"title":"Security scenariosâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#security-scenarios","content":" Git doesn't provide a formal security specification, so to facilitate analysis of Sparo contributions, we've identified usage scenarios that imply security requirements. We welcome your feedback -- please let us know if we've overlooked an important use case or if Git does not behave as described.  ","version":"Next","tagName":"h2"},{"title":"SS1: Safely clone an untrusted repoâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#ss1-safely-clone-an-untrusted-repo","content":" Suppose that an unfamiliar remote Git repository contains malicious files, which includes malicious config files such as .gitattributes, .gitignore, and Git hook scripts. The following operations are expected to be safe:  Using git clone to clone the remote repo.Using git checkout to checkout files.Using git commit to commit modifications of local files.  Git ensures safety by ignoring Git hooks and .gitattributes filters by default. The user must explicitly run a command to &quot;opt-in&quot;, signifying their trust that the repository is free from malicious code. For example, invoking rush install will register predefined Git hooks, because NPM installation involves executing untrusted scripts and therefore signifies trust in the cloned repository. As another example, if .gitattributes references the LFS filter, the user must first opt-in by running git lfs install, signifying their trust that the filter author has implemented security protections against malicious inputs for that filter.  Sparo introduces additional config files such as &lt;profile-name&gt;.json. Parsing of these config files must also treat the inputs as potentially malicious, and provide the same guarantees.  ","version":"Next","tagName":"h3"},{"title":"SS2: Safely clone an untrusted repository parameterâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#ss2-safely-clone-an-untrusted-repository-parameter","content":" A command such as git clone https://github.com/example/project.git will write into a subfolder called project. The Git documentation calls this the &quot;humanish&quot; portion of the URL.  Consider a remote service that receives the REPOSITORY parameter as a text string and then invokes git clone REPOSITORY with correct shell-escaping of the parameter. In calculating the humanish folder name, Git should not incorporate special characters such as .. or / that would cause the operation to write cloned files outside of the intended folder.  And of course, if an explicit target folder is specified using git clone https://github.com/example/project.git my-folder, then no files should be cloned outside of the my-folder folder.  ","version":"Next","tagName":"h3"},{"title":"SS3: Git parameters may include special charactersâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#ss3-git-parameters-may-include-special-characters","content":" Shell interpreters commonly transform expressions involving special characters such as $, %, (, etc. For example:  # Problem: Bash would replace &quot;$project&quot; with the value of # the environment variable whose name is &quot;project&quot;. git clone https://github.com/example/project.git $project   This requires escaping:  # This backslash escape ensures that a literal dollar sign # is included in the created folder name: git clone https://github.com/example/project.git \\$project   When the sparo command-line invokes subprocesses such as git, it must carefully ensure that process arguments are correctly escaped to avoid being transformed by the shell. For example, if \\$project gets expanded by the shell during subprocess invocation, the escaping will be defeated, which could be exploited to circumvent the other Sparo security guarantees. If certain characters cannot be safely escaped by Node.js, they should be rejected with an error message.  ","version":"Next","tagName":"h3"},{"title":"Security assumptionsâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#security-assumptions","content":" It's also useful to point out aspects that are NOT expected to be secure.  ","version":"Next","tagName":"h2"},{"title":"Assumption: Shell environment variables are trustedâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#assumption-shell-environment-variables-are-trusted","content":" For the most part, the git CLI assumes that the shell environment variables are trusted. For example, it relies on the PATH variable to discover the location of the ssh binary, and most of the parent process's variables are passed through to child processes.  Because Sparo the tool is invoked by the Node.js runtime, arbitrary code execution is possible via environment variables such as NODE_OPTIONS.  ","version":"Next","tagName":"h2"},{"title":"Assumption: Command line is generally trustedâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#assumption-command-line-is-generally-trusted","content":" The git command-line accepts parameters such as -c which can trigger execution of arbitrary code. Therefore in general, we assume that the command-line parameters are trusted. However, certain parameters can provide stricter guarantees, for example the &lt;repository&gt; argument for git clone mentioned in SS3.  ","version":"Next","tagName":"h2"},{"title":"Assumption: Commands may consume excessive resourcesâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#assumption-commands-may-consume-excessive-resources","content":" Commands such as git clone may consume an arbitrary amount of disk space or take arbitrarily long to complete. In general, denial-of-service attacks are not considered an important risk for this type of development tool.  ","version":"Next","tagName":"h2"},{"title":"Assumption: STDOUT and STDERR may contain arbitrary charactersâ€‹","type":1,"pageTitle":"Security","url":"/sparo/pages/reference/security#assumption-stdout-and-stderr-may-contain-arbitrary-characters","content":" When invoking the git CLI, the console output may include strings printed by hook scripts or other shell commands. These strings may contain special characters that are unsafe to embed in other contexts such as an HTML document or SQL string literal. It is the responsibility of the calling processes to correctly escape any STDOUT or STDERR output produced by the git or sparo process. ","version":"Next","tagName":"h2"}],"options":{"languages":["en"],"id":"default"}}